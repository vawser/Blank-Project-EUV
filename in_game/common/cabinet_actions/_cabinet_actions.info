#------------------
# Entry
#------------------
<action> = {
    ability = <adm/dip/mil>         # Monarch ability that this action will use (adm/dip/mil)
    
    allow_multiple = <key>          # Flag for whether we can have several of these actions going on at once (yes/no)
    societal_values = <float>       # Amount to change a societal value by
    
    potential = {
        <triggers>
    }
    # Trigger for whether the action is possible (root = country)
    
    allow = {
        <triggers>
    }
    # Trigger for whether the action can start (root = country)
    
    # Each of these is exclusive with each other
    years = <int>                   # Defines how long it takes to be fully implemented. Modifiers will be scaled by how much of this time is completed.
    months = <int>                  # Defines how long it takes to be fully implemented. Modifiers will be scaled by how much of this time is completed.
    weeks = <int>                   # Defines how long it takes to be fully implemented. Modifiers will be scaled by how much of this time is completed.
    days = <int>                    # Defines how long it takes to be fully implemented. Modifiers will be scaled by how much of this time is completed.
    
    progress = <script value>       # Returns the current progress of the action
    
    on_activate = {
        <effects>
    }
    # Effects to apply when the action is chosen (root = cabinet, scope:actor = country, scope:target, scope:target_1 etc)
    
    on_fully_activated = {
        <effects>
    }
    # Fired when the action's implementation reaches 100% (instant if there's no time delay) (root = cabinet, scope:actor = country, scope:target, scope:target_1 etc)
    
    on_deactivate = {
        <effects>
    }
    # Fired when the action is removed (root = cabinet, scope:actor = country, scope:target, scope:target_1 etc)
    
    # All modifiers are multiplied by 1 + (effective ability + cabinet efficiency)*0.05 (CABINET_ACTION_SKILL_MODIFIER in defines)
    country_modifier = {
        potential_trigger = {
            <triggers>
        }
        # Optional: triggers for when this modifier is applied
        
        scale = <value> # Scale of the modifier
    
        <modifiers>
    }
    # Applied to the whole country that the action is in.
    
    province_modifier = {
        potential_trigger = {
            <triggers>
        }
        # Optional: triggers for when this modifier is applied
        
        scale = <value> # Scale of the modifier
    
        <modifiers>
    }
    # Applied to the province the action is in.
    
    location_modifier = {
        potential_trigger = {
            <triggers>
        }
        # Optional: triggers for when this modifier is applied
        
        scale = <value> # Scale of the modifier
    
        <modifiers>
    }
    # Applied to the location the action is in.
    
    is_finished = {
        <triggers>
    }
    # Trigger for whether the action is completed (root = country, scope:target = province)
           
    ai_will_do = {
        <effects>
    }
    # Effect script for the AI to use, scope:actor is the country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc
    
    # Can add multiple of these to allow selection of targets/parameters for the action. They get stored in scope:target, scope:target_1, scope:target_2....etc
    select_trigger = {
        looking_for_a = <type>              # Can be character/location/province/area/region/country/value/boolean
        target_flag = <key>                 # What you want to call this target in the scope (e.g. target, target_1, target_province etc.) 
                                            # Then later you'll use this name to reference what was selected here. If left out it will default to target, target_1, target_2, target_3 etc
                                    
        source = <type>                     # Can be actor/recipient/target/target_1/target_2/target_3/target_4
        source_ai_override = <type>         # Can be actor/recipient/target/target_1/target_2/target_3/target_4 (ai only)
        
        source_flags = <type>               # Options to improve game performance by narrowing down the choice:         
                                            # neighbor, possible_colonial_charters, include_dead, include_any_present, possible_exploration_areas, 
                                            # adjacent_locations, vacant_adjacent_locations, adjacent_provinces, 
                                            # border, border_or_recipients_capital_area, provinces_ai_wants_to_give_away, only_actual_locations
                                    
        source_flags_ai_override = <type>   # Options to improve game performance by narrowing down the choice:         
                                            # neighbor, possible_colonial_charters, include_dead, include_any_present, possible_exploration_areas, 
                                            # adjacent_locations, vacant_adjacent_locations, adjacent_provinces, 
                                            # border, border_or_recipients_capital_area, provinces_ai_wants_to_give_away, only_actual_locations
                                            
        source_global_list = <key>          # Name of global variable list with the list of candidates in: if you have a pre calculated global list of who you want in the select_trigger, use this
        interaction_source_list = {
            <effects>
        }
        # Gives us a list of possible candidates to look at. 
        # scope:actor is the country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc. 
        # Fill the list with add_to_list = source on the scope object
        
        ai_interaction_source_list = {
            <effects>
        }
        # Gives us a list of possible candidates to look at. Applies to AI countries only. 
        # scope:actor is the country, scope:recipient, scope:target, scope:target_1, scope:target_2....etc. 
        # Fill the list with add_to_list = source on the scope object
        
        pre_evaluation_sort_value = <script_value>          # Use this to sort the initial list of possible targets 
                                                            # that pass the trigger and select the top X to evaluate fully
                                                            # Use in conjunction with pre_evaluation_number_to_evaluate_fully
                                                            
        pre_evaluation_number_to_evaluate_fully = <int>     # Number of the top sorted pre-evaluated targets to pass on for full evaluation
                                                            # Use in conjunction with pre_evaluation_sort_value (AI only)
                                                            
        max_targets_for_ui = <int>                          # Number of the top sorted pre-evaluated targets to pass on to the UI for the user to choose from
        cache_targets = <bool>                              # If the list of targets will always be the same, i.e. doesn't depend on any other selection, then set this to yes to save processing
        cache_interaction_source_list = <bool>              # If the interaction source list will always be the same, i.e. doesn't depend on any other selection, then set this to yes to save processing
        cache_order = <bool>                                # If the list of targets will always be in the same order of how good they are at the task, set this to yes to save processing
        
        name = <key>                                        # Localisation name of the title for the selection stage
        
        allow_null = <bool>                                 # Allow the selection of a null object, can be a trigger to check under what circumstances should null be included / excluded instead
        allow_self = <bool>                                 # Allow the actor to be added to the list (only works for countries)
        
        top_widget = <key>                                  # Links to a widget type in the gui files to show at the top of the list. 
        bottom_widget = <key>                               # Links to a widget type in the gui files to show at the bottom of the list. 
        
        column = { 
            data = <column_id> 
            width = <int> 
            icon = <path>
            show_icon_in_cells = <bool>
        } 
        # Adds a column to the UI to search with these can also be defaulted, see \common\attribute_columns
        
        default_sort = <key>                                # Key of the sort you want the selection to default to. 
                                                            # With nothing it will default to the first sort column. 
                                                            # The columns you have are specified in columns = above, the sort keys for the sorts are in \common\attribute_columns\
                                                            
        none_available_msg_key = <key>                      # Key of the localisation used when there are no available targets to choose from (optional)
        
        show_why_not_visible = <bool>                       # True to show why a target might not be visible if there are no targets
        show_why_not_enabled = <bool>                       # True to show why a target might not be enabled if there are no targets
        
        min = <script value>                                # Minimum value for value types
        max = <script value>                                # Maximum value for value types
        step = <script value>                               # Step value for changing value types in the UI
        default = <script value>                            # Default value for value types
        
        map_mode = <map mode tag>                           # Map mode the map will switch to while choosing this target (optional)
        map_color = <script color>                          # Map color for location (root = location, scope:actor/recipient etc)
        only_color_selectable = <bool>                      # Yes to only think about colouring selectable locations; no to be able to colour any location with the script above
        secondary_map_color = <script color>                # Striped map color for location (root = location, scope:actor/recipient etc)
        
        show_if = { 
            <triggers>
        }
        # Determines if the action is shown (root is source scope)
        
        visible = { 
            <trigger>
        }
        # Determines if the action is visible (root is source scope)
        
        enabled = { 
            <trigger>
        }
        # Determines if the action is enabled (root is source scope)
        
        selected = { 
            <trigger>
        }
        # Determines if the action is selected (root is source scope)
        
    }
}